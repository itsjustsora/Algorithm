참고
- 바킹독 알고리즘:재귀 (https://blog.encrypted.gg/943?category=773649)

재귀란
하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

예를 들어, 도미노가 있을 때 첫 번째 도미노가 쓰러지면 마지막에 있는 도미노가 모두 쓰러지는 상황에서
- 절차 지향적 : 첫 번째 도미노가 쓰러져서 두 번째 도미노가 쓰러지고, 두 번째 도미노가 쓰러져서 세 번째가..
- 귀납적 : k번 도미노가 쓰러지면 k+1 도미노도 쓰러지니까 결과적으로 모든 도미노가 쓰러진다.
재귀 문제 풀 때 가장 중요한 것은 절차 지향적 사고 버리기!

재귀 함수의 조건
특정 입력에 대해서 자기 자신을 호출하지 않고 종료되는 Base condition이 있어야 한다.


하노이의 탑 문제
이동 순서
1. n-1개의 원판을 기둥 1에서 기둥 2로 옮긴다.
2. n번 원판을 기둥 1에서 기둥 3으로 옮긴다.
3. n-1개의 원판을 기둥 2에서 3으로 옮긴다.
-> 원판이 n-1개일 때 옮길 수 있으면 원판이 n개일 때도 옮길 수 있다.

원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다는 것과 원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때도 옮길 수 있는 것을 알았으면 귀납적으로 문제를 풀 수 있다.

총 옮긴 횟수
원판 k개를 옮기기 위해 A번 이동이 필요하다고 했을 때, 원판 k+1개를 옮길 때는 k개의 원판을 빈 곳으로 옮길 때 A번,
k+1번 원판을 옮길 때 1번, k개의 원판을 다시 빈 곳에서 목적지로 옮길 때 A번이 필요하니 2A+1번 이동이 필요한 것을 알 수 있다.

여기서 또 절차 지향적 사고로 func(1,3,5)를 부르면 func(1,3,5)가 func(1,2,4)를 부르고.. 이런 식으로 생각하면 끝없이 들어가고 복잡하니까
생각 자체를 귀납적으로 해야 한다.


짦은 회고
절차적 사고에 너무 익숙해져 있는 건지 도대체 귀납적 사고는 어떻게 해야한다는 건지 너무 어렵다. 재귀 문제 풀면서 진짜 처음으로 내가 코테를 공부하는 게 의미가 있을까 생각했다.
내가 진짜 이렇게 멍청한가? 특히 병합정렬 할 때는 연습장에 코드 한 줄 한 줄 적으면서 과정 이해하려고 엄청 노력했다. 결국엔 다시 풀어야겠지만...
바킹독님은 재귀가 원래 어려운 거라고 하시는데,, 모르겠다. 계속 하면 언젠가 이해하겠지.

